import os
import copy
import subprocess
import time
import shutil
import multiprocessing  # ADDED: For Hardware Detection
from PySide6.QtWidgets import *
from PySide6.QtCore import *
from PySide6.QtGui import *

# --- TITANIUM BRAIN STACK INTEGRATION ---
# Graceful fallback mechanisms for the AI subsystems
try:
    from core.ai_engine import AIEngine
    from ui.export_dialog import ExportDialog
    from core.ai_worker import TitaniumWorker
    from core.db_sync import DatabaseSync
    from core.project_manager import AlbumTracker
    from core.safety_net import SafetyNet
    from core.cache_manager import EmbeddingCache
    from core.intelligent_search import IntelligentSearch
    TITANIUM_AVAILABLE = True
except ImportError:
    TITANIUM_AVAILABLE = False
    print(">> [SYSTEM] Titanium Stack not found. Running in Engine-Only Mode.")

# ==================================================================================
#   PHASE 1: THE ENGINE ROOM
#   (Threading, Caching, and File System Scanning)
# ==================================================================================

class ImageCache(QObject):
    """
    ARCHITECTURAL UPGRADE: Thread-Safe True LRU Cache.
    Prevents memory corruption when multiple threads access the cache,
    and correctly prioritizes recently viewed images.
    """
    def __init__(self):
        super().__init__()
        self.cache = {} 
        self.max_items = 1500 
        self.lock = QMutex()  # ADDED: Critical for Thread Safety

    def get(self, key):
        QMutexLocker(self.lock) # Thread safety lock
        if key in self.cache:
            # TRUE LRU LOGIC: Move accessed item to the end (most recently used)
            value = self.cache.pop(key)
            self.cache[key] = value
            return value
        return None

    def insert(self, key, pixmap):
        QMutexLocker(self.lock)
        if key in self.cache:
            self.cache.pop(key)
        elif len(self.cache) >= self.max_items:
            try:
                # Remove the first item (least recently used)
                self.cache.pop(next(iter(self.cache)))
            except (StopIteration, KeyError): pass
        self.cache[key] = pixmap

# Global Singleton Instance
global_cache = ImageCache()

class LoaderSignals(QObject):
    loaded = Signal(str, QPixmap)

class ThumbnailRunnable(QRunnable):
    """
    Asynchronous worker for generating thumbnails off the main thread 
    to prevent UI freezing during rapid scrolls.
    """
    def __init__(self, path, size, signals):
        super().__init__()
        self.path = path
        self.size = size
        self.signals = signals

    def run(self):
        if not os.path.exists(self.path): return
        # Auto-detects efficient memory loading
        reader = QImageReader(self.path)
        reader.setAutoTransform(True) # FIX: Handles EXIF rotation
        
        # Performance Guard: Don't try to read corrupted headers
        if reader.canRead():
            reader.setScaledSize(self.size)
            img = reader.read()
            if not img.isNull():
                pix = QPixmap.fromImage(img)
                self.signals.loaded.emit(self.path, pix)

class FolderScanner(QThread):
    """
    Industrial Scanner: Capable of ingesting 20,000+ files without UI lag.
    """
    batch_found = Signal(list) 
    finished = Signal()

    def __init__(self, folder_path):
        super().__init__()
        self.folder_path = folder_path
        self._is_running = True # ADDED: For safe cancellation

    def run(self):
        valid_exts = {'.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.webp', '.raw', '.arw'}
        batch = []
        # Batch size 50 is optimized for high-throughput scanning
        BATCH_SIZE = 50 
        
        try:
            with os.scandir(self.folder_path) as entries:
                for entry in entries:
                    if not self._is_running: break
                    if entry.is_file():
                        # Fast extension check (lower overhead than tuple check)
                        ext = os.path.splitext(entry.name)[1].lower()
                        if ext in valid_exts:
                            batch.append(entry.path)
                            if len(batch) >= BATCH_SIZE:
                                self.batch_found.emit(batch)
                                batch = []
                                self.msleep(10) # Tiny yield to let UI breathe
            if batch and self._is_running: 
                self.batch_found.emit(batch)
        except Exception as e:
            print(f"‚ö†Ô∏è Scanner Exception: {e}")
        self.finished.emit()

    def stop(self):
        self._is_running = False

class AIWorker(QThread):
    """
    Legacy Worker for fallback operations if Titanium Stack is offline.
    """
    progress_update = Signal(int, int, str)
    result_ready = Signal(int, dict)
    finished_scan = Signal()

    def __init__(self, paths, ai_engine):
        super().__init__()
        self.paths = paths
        self.ai = ai_engine
        self.is_running = True

    def run(self):
        total = len(self.paths)
        start_time = time.time()
        for i, path in enumerate(self.paths):
            if not self.is_running: break
            try:
                analysis = self.ai.analyze_technical_quality(path)
            except AttributeError:
                analysis = {'score': 0, 'focus': 'PENDING', 'eyes': 'N/A'}
            self.result_ready.emit(i, analysis)
            if i % 10 == 0:
                elapsed = time.time() - start_time
                if elapsed > 0:
                    avg = elapsed / (i + 1)
                    rem = int((total - i) * avg)
                    msg = f"{rem//60}m {rem%60}s Left"
                    self.progress_update.emit(i + 1, total, msg)
                self.msleep(1)
        self.finished_scan.emit()

    def stop(self):
        self.is_running = False

# ==================================================================================
#   PHASE 2: VISUAL INTERFACE PRIMITIVES
#   (Custom Widgets, Styling, and Badges)
# ==================================================================================

class VIPBadge(QLabel):
    def __init__(self, level="VVIP", parent=None):
        super().__init__(parent)
        self.setFixedSize(36, 20)
        color = "#D4B37D" if level == "VVIP" else "#C0C0C0"
        text = "üëëüëë" if level == "VVIP" else "üëë"
        self.setText(text)
        self.setStyleSheet(f"color: {color}; font-size: 10px; font-weight: bold; background: rgba(0,0,0,0.5); border-radius: 4px;")
        self.setAlignment(Qt.AlignCenter)

class ManualMarker(QLabel):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(18, 18)
        self.setText("üë§")
        self.setStyleSheet("color: #D4B37D; font-size: 11px; background: rgba(0,0,0,0.6); border-radius: 9px;")
        self.setAlignment(Qt.AlignCenter)
        self.setToolTip("Hand-picked by User")

class ConfidenceDot(QFrame):
    def __init__(self, level="high", parent=None):
        super().__init__(parent)
        self.setFixedSize(8, 8)
        color = {"high": "#98C379", "medium": "#E5C07B", "low": "#E06C75"}.get(level, "#555")
        self.setStyleSheet(f"background-color: {color}; border-radius: 4px;")

class QueueChip(QPushButton):
    def __init__(self, text, parent=None):
        super().__init__(text, parent)
        self.setCheckable(True)
        self.setFixedHeight(28)
        self.setCursor(Qt.PointingHandCursor)
        self.setFocusPolicy(Qt.NoFocus)
        self.setStyleSheet("""
            QPushButton { background: #111; color: #888; border: 1px solid #333; border-radius: 14px; padding: 0 15px; font-size: 10px; font-weight: bold; }
            QPushButton:checked { background: #D4B37D; color: #000; border: 1px solid #D4B37D; }
            QPushButton:hover { border-color: #555; }
        """)

class MagicAnalyzeButton(QPushButton):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setText("‚ú® ANALYZE MAGIC")
        self.setCursor(Qt.PointingHandCursor)
        self.setFixedSize(160, 36)
        self.setFocusPolicy(Qt.NoFocus)
        self.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #D4B37D, stop:1 #C5A96F);
                color: #000; border: 1px solid #D4B37D; border-radius: 6px; font-weight: bold; 
            }
            QPushButton:hover { background: #E6C89C; }
            QPushButton:pressed { background: #B39260; }
            QPushButton:disabled { background: #333; color: #555; border: 1px solid #333; }
        """)

    def set_loading(self, is_loading):
        self.setEnabled(not is_loading)
        self.setText("‚è≥ STOP" if is_loading else "‚ú® ANALYZE MAGIC")

    def update_progress(self, current, total):
        self.setText(f"üß† {current}/{total}")

# ==================================================================================
#   PHASE 3: THE GRID SYSTEM
#   (Intelligent Card Rendering & Metadata Display)
# ==================================================================================

class GridCard(QFrame):
    clicked = Signal(int, object)
    double_clicked = Signal(int)
    image_loaded = Signal()

    def __init__(self, index, data, is_selected, is_multi, width=240):
        super().__init__()
        self.index = index; self.data = data; self.loaded = False
        self.setCursor(Qt.PointingHandCursor)
        
        # 1. ARCHITECTURAL DIMENSIONS
        if width < 100: width = 240
        # Increased vertical space for dual-row luxury metadata
        self.setFixedSize(width, width + 45) 
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # 2. IMAGE THUMBNAIL AREA
        self.lbl_thumb = QLabel("...")
        self.lbl_thumb.setAlignment(Qt.AlignCenter)
        self.lbl_thumb.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Ignored) 
        self.lbl_thumb.setStyleSheet("color:#444; border:none; background:transparent;")
        layout.addWidget(self.lbl_thumb, 1) 
        
        # 3. LUXURY METADATA STACK (Dual Layer)
        self.desc_bar = QFrame()
        self.desc_bar.setFixedHeight(45) # Expanded for description + tags
        self.desc_bar.setStyleSheet("""
            QFrame { 
                background: rgba(0,0,0,0.95); 
                border-top: 1px solid #222;
                border-bottom-left-radius: 10px; 
                border-bottom-right-radius: 10px; 
            }
        """)
        m_lay = QVBoxLayout(self.desc_bar)
        m_lay.setContentsMargins(8, 4, 8, 4)
        m_lay.setSpacing(2)

        # Row 1: Filename & Status
        row1 = QHBoxLayout()
        fname = os.path.basename(data['path'])
        short_name = fname[:15] + ".." if len(fname) > 15 else fname
        lbl_name = QLabel(short_name)
        lbl_name.setStyleSheet("color: #EEE; font-size: 10px; font-weight: bold; border:none; background:transparent;")
        
        status_text = data.get('status', 'pending').upper() if data.get('status') != 'pending' else "REVIEW"
        status_col = "#98C379" if data.get('status') == 'keep' else "#E06C75" if data.get('status') == 'reject' else "#E5C07B"
        self.lbl_status = QLabel(status_text)
        self.lbl_status.setStyleSheet(f"color: {status_col}; font-weight:900; font-size:9px; border:none; background:transparent;")
        
        row1.addWidget(lbl_name)
        row1.addStretch()
        row1.addWidget(self.lbl_status)
        m_lay.addLayout(row1)

        # Row 2: Description & Tags (The "Readable" Logic)
        row2 = QHBoxLayout()
        # Fallback to #AI_Pending if no description exists yet
        tags = data.get('tags', "#Processing...")
        lbl_tags = QLabel(tags)
        lbl_tags.setStyleSheet("color: #D4B37D; font-size: 9px; font-style: italic; border:none; background:transparent;")
        
        row2.addWidget(lbl_tags)
        row2.addStretch()
        
        # Mini AI Badge (Luxury Symbol)
        if data.get('score', 0) >= 90:
            lbl_luxury = QLabel("‚ú®")
            lbl_luxury.setStyleSheet("background:transparent; border:none;")
            row2.addWidget(lbl_luxury)
            
        m_lay.addLayout(row2)
        layout.addWidget(self.desc_bar)
        
        # 4. INITIALIZE OVERLAYS & STYLE
        self.setup_overlays()
        self.update_style(is_selected, is_multi)
        self.trigger_load()

    def setup_overlays(self):
        """Restores floating indicators without cluttering the main bar."""
        # 1. Glass-Box Score Badge
        score = self.data.get('score', 0)
        if score > 0:
            status = self.data.get('status', 'pending')
            color = "#98C379" if status == 'keep' else "#E06C75" if status == 'reject' else "#E5C07B"
            self.debug_badge = QLabel(f"{int(score)}%", self)
            self.debug_badge.setStyleSheet(f"""
                background: rgba(0,0,0,0.8); color: {color}; font-weight: bold; 
                font-size: 9px; border: 1px solid {color}; border-radius: 4px; padding: 2px 5px;
            """)
            self.debug_badge.move(8, 8)
            self.debug_badge.show()

        # 2. Luxury VVIP/VIP Badges
        vip = self.data.get('vip_level', 'None')
        if vip != 'None' and TITANIUM_AVAILABLE:
            self.vip_label = VIPBadge(vip, self)
            self.vip_label.move(self.width() - 40, 8)
            self.vip_label.show()

    def trigger_load(self):
        cached = global_cache.get(self.data['path'])
        if cached: self.set_image(cached); return
        sig = LoaderSignals(); sig.loaded.connect(self.on_worker_loaded)
        QThreadPool.globalInstance().start(ThumbnailRunnable(self.data['path'], self.size(), sig))

    def on_worker_loaded(self, path, pix):
        if path != self.data['path']: return
        global_cache.insert(path, pix)
        self.set_image(pix)
        self.image_loaded.emit()

    def set_image(self, pixmap):
        self.loaded = True
        self.lbl_thumb.setText("")
        # Preservation of smooth transformation for Iris XE graphics
        self.lbl_thumb.setPixmap(pixmap.scaled(self.lbl_thumb.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))

    def resizeEvent(self, event):
        if self.lbl_thumb.pixmap(): self.lbl_thumb.setScaledContents(False)
        super().resizeEvent(event)

    def update_style(self, is_selected, is_multi):
        """Nervous system feedback: Syncs border with AI/Manual status."""
        border = "#D4B37D" if is_selected else "#222"
        bg = "#000000"
        if is_multi: border = "#C5A96F"; bg = "#111"
        
        status = self.data.get('status', 'pending')
        if status == 'keep': border = "#98C379"
        elif status == 'reject': border = "#E06C75"
        elif status == 'pending' and self.data.get('score', 0) > 0: border = "#E5C07B"
            
        self.setStyleSheet(f"GridCard {{ background:{bg}; border:2px solid {border}; border-radius:10px; }}")

    def mousePressEvent(self, e):
        if e.button() == Qt.LeftButton: self.clicked.emit(self.index, e.modifiers())
        super().mousePressEvent(e)

    def mouseDoubleClickEvent(self, e):
        if e.button() == Qt.LeftButton: self.double_clicked.emit(self.index)
        super().mouseDoubleClickEvent(e)

    def contextMenuEvent(self, e):
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu { background-color: #111; border: 1px solid #D4B37D; color: #FFF; padding: 5px; } 
            QMenu::item { padding: 5px 20px; } 
            QMenu::item:selected { background-color: #D4B37D; color: #000; }
        """)
        act_reveal = menu.addAction("üìÇ  Reveal")
        act_copy = menu.addAction("üìã  Copy Path")
        action = menu.exec(e.globalPos())
        path = os.path.normpath(self.data['path'])
        if action == act_reveal: subprocess.Popen(f'explorer /select,"{path}"')
        elif action == act_copy: QApplication.clipboard().setText(path)

# ==================================================================================
#   PHASE 4: THE ZEN VIEWER
#   (High-Fidelity Single Image Inspection)
# ==================================================================================

class ZenViewer(QGraphicsView):
    double_clicked = Signal()
    def __init__(self):
        super().__init__()
        self.current_path = None 
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.setStyleSheet("background:#000; border:none;")
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.pix_item = QGraphicsPixmapItem()
        self.scene.addItem(self.pix_item)

    def set_image(self, path):
        self.current_path = path
        self.resetTransform()
        
        # FIX: Direct Load for Instant Flow
        if os.path.exists(path):
            try:
                reader = QImageReader(path)
                reader.setAutoTransform(True)
                if reader.canRead():
                    # Cap max size for performance
                    reader.setScaledSize(QSize(3840, 2160)) 
                    img = reader.read()
                    if not img.isNull():
                        self._on_loaded(path, QPixmap.fromImage(img))
                        return
            except: pass

        # Fallback
        sig = LoaderSignals(); sig.loaded.connect(self._on_loaded)
        QThreadPool.globalInstance().start(ThumbnailRunnable(path, QSize(4000, 4000), sig))

    def _on_loaded(self, path, pix):
        if path == self.current_path or self.current_path is None: 
            self.pix_item.setPixmap(pix)
            self.scene.setSceneRect(self.pix_item.boundingRect())
            self.fitInView(self.pix_item, Qt.KeepAspectRatio)

    def wheelEvent(self, e): 
        factor = 1.15 if e.angleDelta().y() > 0 else 1/1.15
        self.scale(factor, factor)

    def mouseDoubleClickEvent(self, e):
        self.double_clicked.emit()
        super().mouseDoubleClickEvent(e)

    def contextMenuEvent(self, e):
        if not self.current_path: return
        menu = QMenu(self)
        menu.setStyleSheet("QMenu { background-color: #111; border: 1px solid #D4B37D; color: #FFF; padding: 5px; } QMenu::item { padding: 5px 20px; } QMenu::item:selected { background-color: #D4B37D; color: #000; }")
        act_reveal = menu.addAction("üìÇ  Reveal"); act_copy = menu.addAction("üìã  Copy Path")
        menu.addSeparator(); act_search = menu.addAction("üîç  Find Similar Faces")
        action = menu.exec(e.globalPos())
        path = os.path.normpath(self.current_path)
        if action == act_reveal: subprocess.Popen(f'explorer /select,"{path}"')
        elif action == act_copy: QApplication.clipboard().setText(path)
        elif action == act_search: print(f"Triggering Intelligent Search for {path}")

# ==================================================================================
#   PHASE 5: THE MASTER CONTROLLER (GalleryView)
#   (Logic Aggregation, State Management, and AI Orchestration)
# ==================================================================================

class GalleryView(QWidget):
    image_selected = Signal(str)
    
    def __init__(self, parent=None, db=None):
        super().__init__(parent)
        
        # Hardware-aware threading
        max_threads = multiprocessing.cpu_count()
        QThreadPool.globalInstance().setMaxThreadCount(max_threads)
        
        self.db = db
        self.ai = AIEngine() if TITANIUM_AVAILABLE else None
        
        self.current_folder = None
        self.image_data = []
        self.path_registry = set()
        
        self.current_index = 0
        self.multi_selection = set()
        self.filter_state = "all"
        self.visible_indices = []
        self.rendered_count = 0
        self.BATCH_SIZE = 50 
        self.GRID_COLS = 3
        self.auto_advance = True
        self.loaded_thumbnails_count = 0
        self.undo_stack = []
        self.redo_stack = []
        self.lights_out = False
        self.ai_worker = None # The primary suspect in the crash
        self.scanner_worker = None
        self.album_target = 100
        self.is_rendering_batch = False
        
        if TITANIUM_AVAILABLE:
            self.album_tracker = AlbumTracker()
            self.safety_net = SafetyNet()

        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(0)
        
        self.setup_guidance_banner()
        self.setup_top_bar()
        self.setup_queue_bar()
        self.setup_filter_bar() 
        
        self.content_layout = QHBoxLayout()
        self.layout.addLayout(self.content_layout)
        
        self.sidebar_panel = QFrame()
        self.sidebar_panel.setFixedWidth(200)
        self.sidebar_panel.setStyleSheet("background: #050505; border-right: 1px solid #222;")
        self.sidebar_layout = QVBoxLayout(self.sidebar_panel)
        self.setup_sidebar_filters() 
        self.content_layout.addWidget(self.sidebar_panel)

        self.view_stack = QStackedWidget()
        self.content_layout.addWidget(self.view_stack)
        
        self.setup_grid_ui()
        self.setup_insight_panel()
        
        self.setFocusPolicy(Qt.StrongFocus)

    # --- ARCHITECTURAL FIX: SURGICAL THREAD MANAGEMENT ---

    def trigger_ai_analysis(self):
        paths = [d['path'] for d in self.image_data]
        if not paths: return
        
        # Prevent double triggers
        if self.ai_worker and self.ai_worker.isRunning():
            return

        self.btn_analyze.setText("Analyzing...")
        self.btn_analyze.setEnabled(False)
        self.progress_bar.show()
        self.progress_bar.setRange(0, len(paths))

        # Re-initialize worker
        self.ai_worker = TitaniumWorker(paths) if TITANIUM_AVAILABLE else AIWorker(paths, self.ai)
        
        # Standard signal connections
        if TITANIUM_AVAILABLE:
            self.ai_worker.result_ready.connect(self.handle_ai_result)
            self.ai_worker.progress.connect(self.update_ai_progress)
            self.ai_worker.finished.connect(self.on_ai_finished)
        else:
            self.ai_worker.result_ready.connect(self.handle_ai_result)
            self.ai_worker.progress_update.connect(self.update_ai_progress_legacy)
            self.ai_worker.finished_scan.connect(self.on_ai_finished)
        
        # THE FIX: Ensure Python doesn't garbage collect the worker too early
        self.ai_worker.finished.connect(self.ai_worker.deleteLater) 
        self.ai_worker.start()

    def on_ai_finished(self):
        """Finalizes UI and safely parks the worker thread."""
        print("üèÅ [SYSTEM] Analysis Cycle Complete. Parking Threads...")
        
        # 1. UI Reset
        if hasattr(self, 'btn_analyze'):
            self.btn_analyze.setText("‚ú® RE-ANALYZE")
            self.btn_analyze.setEnabled(True)
        
        if hasattr(self, 'progress_bar'):
            self.progress_bar.hide()
            
        if hasattr(self, 'lbl_insight'):
            total = len(self.image_data)
            self.lbl_insight.setText(f"‚úÖ AI Analysis Complete: {total} images.")
        
        self.update_filter_styles()

        # 2. THE FIX: Cleanly unregister the thread from memory
        if self.ai_worker:
            self.ai_worker.quit()
            # We don't delete manually; deleteLater (connected in trigger) handles it safely.

    def closeEvent(self, event):
        """INDUSTRIAL SHUTDOWN: Verifies all threads are dead before window closes."""
        print("üõë [SYSTEM] Initiating Shutdown Protocol...")
        
        # Shutdown Scanner
        if self.scanner_worker and self.scanner_worker.isRunning():
            self.scanner_worker.stop()
            self.scanner_worker.wait(2000) # Wait up to 2 seconds for a clean exit
            
        # Shutdown AI Worker
        if self.ai_worker and self.ai_worker.isRunning():
            if hasattr(self.ai_worker, 'stop'): self.ai_worker.stop()
            self.ai_worker.quit()
            self.ai_worker.wait(2000) 
            
        QThreadPool.globalInstance().clear()
        QThreadPool.globalInstance().waitForDone(2000)
        
        event.accept()

    # --- REMAINING LOGIC PRESERVED ---
    # [Rest of the class methods: load_images, on_batch_found, rebuild_grid, etc.]
    # --- UI INIT METHODS ---

    def setup_guidance_banner(self):
        self.guidance_banner = QFrame()
        self.guidance_banner.setFixedHeight(40)
        self.guidance_banner.setStyleSheet("background: #111; border-bottom: 1px solid #D4B37D;")
        g_lay = QHBoxLayout(self.guidance_banner)
        msg = QLabel("‚ú® You can start selecting now. AI insights will be available when analysis is ready.")
        msg.setStyleSheet("color: #D4B37D; font-size: 11px; font-weight: bold;")
        close_btn = QPushButton("‚úï")
        close_btn.setFixedSize(20,20)
        # FIX: Prevent buttons from stealing shortcut focus
        close_btn.setFocusPolicy(Qt.NoFocus)
        close_btn.setStyleSheet("border:none; color:#666;")
        close_btn.clicked.connect(self.guidance_banner.hide)
        g_lay.addWidget(msg); g_lay.addStretch(); g_lay.addWidget(close_btn)
        self.layout.addWidget(self.guidance_banner)
        self.guidance_banner.hide()

    def setup_top_bar(self):
        self.top_bar = QFrame(); self.top_bar.setFixedHeight(60)
        self.top_bar.setStyleSheet("background:#000; border-bottom:1px solid #222;")
        t_lay = QHBoxLayout(self.top_bar); t_lay.setContentsMargins(20,0,20,0)
        title = QLabel("TITANIUM WORKFLOW")
        title.setStyleSheet("color:#D4B37D; font-weight:bold; font-size:14px; letter-spacing:2px;")
        t_lay.addWidget(title); t_lay.addStretch()
        
        self.btn_analyze = MagicAnalyzeButton()
        self.btn_analyze.setFocusPolicy(Qt.NoFocus)
        self.btn_analyze.clicked.connect(self.trigger_ai_analysis)
        t_lay.addWidget(self.btn_analyze); t_lay.addSpacing(20)
        
        # FIX: SETTINGS BUTTON FOR GRID SIZE
        self.btn_settings = QPushButton("‚öôÔ∏è Grid")
        self.btn_settings.setFocusPolicy(Qt.NoFocus)
        self.btn_settings.setStyleSheet("color:#AAA; border:1px solid #333; padding:5px;")
        self.btn_settings.clicked.connect(self.cycle_grid_size)
        t_lay.addWidget(self.btn_settings); t_lay.addSpacing(10)

        self.btn_export = QPushButton("EXPORT")
        self.btn_export.setCursor(Qt.PointingHandCursor); self.btn_export.setFixedHeight(36)
        self.btn_export.setFocusPolicy(Qt.NoFocus)
        self.btn_export.setStyleSheet("background: #222; color: #FFF; border: 1px solid #444; border-radius: 6px; font-weight: bold; padding: 0 15px;")
        self.btn_export.clicked.connect(self.launch_export)
        t_lay.addWidget(self.btn_export); t_lay.addSpacing(20)
        
        btn_grid = QPushButton("GRID (G)"); btn_grid.clicked.connect(lambda: self.set_mode(0))
        btn_zen = QPushButton("ZEN (E)"); btn_zen.clicked.connect(lambda: self.set_mode(1))
        
        btn_focus = QPushButton("üëÅ"); btn_focus.setFixedSize(36, 36)
        btn_focus.setToolTip("Toggle Focus Mode (L)")
        btn_focus.clicked.connect(self.toggle_lights_out)

        for b in [btn_grid, btn_zen, btn_focus]:
            b.setFocusPolicy(Qt.NoFocus)
            b.setStyleSheet("background:#111; color:#D4B37D; border:1px solid #333; padding:8px 10px; border-radius:6px; font-weight:bold;")
            b.setCursor(Qt.PointingHandCursor); t_lay.addWidget(b)
        self.layout.addWidget(self.top_bar)

    def setup_queue_bar(self):
        self.queue_bar = QFrame(); self.queue_bar.setFixedHeight(50)
        self.queue_bar.setStyleSheet("background: #050505; border-bottom: 1px solid #111;")
        q_lay = QHBoxLayout(self.queue_bar); q_lay.setContentsMargins(20, 0, 20, 0)
        q_lay.addWidget(QLabel("PRIORITY QUEUES:"))
        self.chip_vvip = QueueChip("VVIP PENDING"); q_lay.addWidget(self.chip_vvip)
        self.chip_risk = QueueChip("VVIP AT RISK"); q_lay.addWidget(self.chip_risk)
        self.chip_emo = QueueChip("EMOTIONAL"); q_lay.addWidget(self.chip_emo)
        q_lay.addStretch()
        self.layout.addWidget(self.queue_bar)

    def setup_filter_bar(self):
        self.filter_bar = QFrame()
        self.filter_bar.setFixedHeight(45)
        self.filter_bar.setStyleSheet("background:#050505; border-bottom:1px solid #222;")
        f_lay = QHBoxLayout(self.filter_bar)
        
        # DEFINING THE FIVE PRIMARY BUCKETS (All original logic preserved)
        self.btn_all = QPushButton("ALL (0)")
        self.btn_keep = QPushButton("KEEP (0)")
        self.btn_pending = QPushButton("PENDING (0)")
        self.btn_reject = QPushButton("REJECT (0)")
        self.btn_ai_best = QPushButton("‚ú® AI BEST (0)")

        # Connections (Atomic preservation of your existing signal map)
        self.btn_all.clicked.connect(lambda: self.set_filter("all"))
        self.btn_keep.clicked.connect(lambda: self.set_filter("keep"))
        self.btn_pending.clicked.connect(lambda: self.set_filter("pending"))
        self.btn_reject.clicked.connect(lambda: self.set_filter("reject"))
        self.btn_ai_best.clicked.connect(lambda: self.set_filter("ai_best"))
        
        for b in [self.btn_all, self.btn_keep, self.btn_pending, self.btn_reject, self.btn_ai_best]:
            b.setFocusPolicy(Qt.NoFocus)
            b.setFixedWidth(110)
            b.setCursor(Qt.PointingHandCursor) # Luxury UX feedback
            f_lay.addWidget(b)
            
        f_lay.addStretch()

        # LUXURY HOOK: Active Tag Indicator
        # This shows the user what sub-filter (like #Blurry or #ClosedEyes) is active.
        self.lbl_active_tag = QLabel("")
        self.lbl_active_tag.setStyleSheet("color: #D4B37D; font-family: Consolas; font-size: 10px; font-weight: bold; margin-right: 20px;")
        f_lay.addWidget(self.lbl_active_tag)
        
        self.layout.addWidget(self.filter_bar)

    def setup_sidebar_filters(self):
        label = QLabel("SUBJECT FILTERS")
        label.setStyleSheet("color: #666; font-size: 9px; font-weight: bold; margin-top: 10px;")
        self.sidebar_layout.addWidget(label)
        self.btn_no_face = QPushButton("NO FACES")
        self.btn_single_face = QPushButton("SINGLE SUBJECT")
        self.btn_group_face = QPushButton("GROUP SHOTS (5+)")
        for b in [self.btn_no_face, self.btn_single_face, self.btn_group_face]:
            b.setCheckable(True)
            b.setFocusPolicy(Qt.NoFocus)
            b.setStyleSheet("QPushButton { text-align: left; padding: 8px; color: #AAA; border: none; } QPushButton:checked { color: #D4B37D; font-weight: bold; }")
            self.sidebar_layout.addWidget(b)
        self.sidebar_layout.addStretch()

    def setup_grid_ui(self):
        self.page_grid = QWidget(); self.g_lay = QVBoxLayout(self.page_grid)
        self.scroll = QScrollArea(); self.scroll.setWidgetResizable(True)
        self.scroll.setStyleSheet("background:#000; border:none;")
        self.scroll.verticalScrollBar().valueChanged.connect(self.check_scroll_position)
        
        self.grid_container = QWidget()
        self.grid_layout = QGridLayout(self.grid_container)
        self.grid_layout.setSpacing(10)
        self.grid_layout.setContentsMargins(15,15,15,15)
        self.scroll.setWidget(self.grid_container)
        self.g_lay.addWidget(self.scroll)
        
        # --- ZEN MODE ---
        self.page_zen = QWidget(); self.z_lay = QVBoxLayout(self.page_zen)
        
        # FIX: Zen Header Metadata
        self.lbl_zen_header = QLabel("FILENAME.JPG")
        self.lbl_zen_header.setStyleSheet("color: #AAA; font-size: 14px; padding: 10px; font-weight:bold;")
        self.lbl_zen_header.setAlignment(Qt.AlignCenter)
        self.z_lay.addWidget(self.lbl_zen_header)

        self.zen_viewer = ZenViewer()
        self.zen_viewer.double_clicked.connect(lambda: self.set_mode(0))
        self.z_lay.addWidget(self.zen_viewer, 8)
        
        self.filmstrip_area = QScrollArea()
        self.filmstrip_area.setFixedHeight(120)
        self.filmstrip_area.setWidgetResizable(True)
        self.filmstrip_area.setStyleSheet("background:#050505; border-top:1px solid #D4B37D;")
        self.strip_container = QWidget()
        self.strip_layout = QHBoxLayout(self.strip_container)
        self.strip_layout.setAlignment(Qt.AlignLeft)
        self.filmstrip_area.setWidget(self.strip_container)
        self.z_lay.addWidget(self.filmstrip_area, 2)
        
        self.view_stack.addWidget(self.page_grid)
        self.view_stack.addWidget(self.page_zen)

    def setup_insight_panel(self):
        self.insight_panel = QFrame(); self.insight_panel.setFixedHeight(30)
        self.insight_panel.setStyleSheet("background:#050505; border-top:1px solid #222;")
        self.i_lay = QHBoxLayout(self.insight_panel); self.i_lay.setContentsMargins(10, 0, 10, 0)
        
        self.lbl_insight = QLabel("SYSTEM READY")
        self.lbl_insight.setStyleSheet("color:#AAA; font-size:11px; font-family:Consolas; letter-spacing:1px;")
        
        self.lbl_album = QLabel("ALBUM: 0/100")
        self.lbl_album.setStyleSheet("color:#D4B37D; font-size:10px; font-weight:bold; padding-right:20px;")
        
        self.progress_bar = QProgressBar(); self.progress_bar.setFixedWidth(300); self.progress_bar.setFixedHeight(4); self.progress_bar.setTextVisible(False)
        self.progress_bar.setStyleSheet("QProgressBar { border: none; background: #111; border-radius: 2px; } QProgressBar::chunk { background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #C5A96F, stop:1 #D4B37D); border-radius: 2px; }")
        self.progress_bar.hide()
        
        self.i_lay.addWidget(self.lbl_insight); self.i_lay.addStretch()
        self.i_lay.addWidget(self.lbl_album); self.i_lay.addWidget(self.progress_bar)
        self.layout.addWidget(self.insight_panel)

    # --- BRAIN INTEGRATION & ANALYSIS ---

    def trigger_ai_analysis(self):
        """State-aware trigger: Checks if analysis has already run."""
        
        # 1. INDUSTRY STANDARD: Confirmation check for Re-Analysis
        if hasattr(self, 'btn_analyze') and "RE-ANALYZE" in self.btn_analyze.text():
            from PySide6.QtWidgets import QMessageBox
            confirm = QMessageBox.question(
                self, "Re-Run Analysis?", 
                "AI analysis is already complete. Re-running will update all scores. Continue?",
                QMessageBox.Yes | QMessageBox.No
            )
            if confirm == QMessageBox.No:
                return  # Stop here if they click No

        # 2. Preparation
        paths = [d['path'] for d in self.image_data]
        if not paths: return
        
        if hasattr(self, 'btn_analyze'):
            self.btn_analyze.setText("Analyzing...")
            self.btn_analyze.setEnabled(False) # Prevent double-clicks

        if hasattr(self, 'progress_bar'):
            self.progress_bar.show()
            self.progress_bar.setRange(0, len(paths))

        # 3. Start the Engine (Direct Signal Connections)
        self.ai_worker = TitaniumWorker(paths) if TITANIUM_AVAILABLE else AIWorker(paths, self.ai)
        
        if TITANIUM_AVAILABLE:
            self.ai_worker.result_ready.connect(self.handle_ai_result)
            self.ai_worker.progress.connect(self.update_ai_progress)
            self.ai_worker.finished.connect(self.on_ai_finished)
        else:
            self.ai_worker.result_ready.connect(self.handle_ai_result)
            self.ai_worker.progress_update.connect(self.update_ai_progress_legacy)
            self.ai_worker.finished_scan.connect(self.on_ai_finished)
        
        self.ai_worker.start()

    def handle_ai_result(self, result):
        """CALIBRATED LOGIC: Matches the Brain's 50% benchmark."""
        for i, img in enumerate(self.image_data):
            if img['path'] == result['path']:
                img.update(result)
                
                # Force score to float
                raw_score = float(result.get('score', 0))
                
                # --- NEW REALITY THRESHOLDS ---
                # Since a perfect box got 50%, we scale our expectations.
                # > 45% = Excellent (Keep)
                # < 15% = Garbage (Reject)
                # 15-45% = Review (Pending)
                
                if raw_score >= 45: 
                    img['status'] = 'keep'      # GREEN
                elif raw_score <= 15:
                    img['status'] = 'reject'    # RED
                else:
                    img['status'] = 'pending'   # GOLD
                
                # Visual Update
                self.update_card_style(i)
                self.update_filter_styles()
                
                # Print the truth to the terminal
                print(f"üéØ Calibrated Result: {os.path.basename(img['path'])} | Score: {raw_score}% | Verdict: {img['status'].upper()}")
                break

    def update_ai_progress(self, current=0, total=0):
        """Robust progress updater that won't crash on missing args."""
        try:
            # Prevent Division by Zero
            if total <= 0: 
                total = len(self.image_data)
                
            percent = int((current / total) * 100)
            
            # Update the button text safely
            if hasattr(self, 'btn_analyze'):
                self.btn_analyze.setText(f"Analyzing... {percent}%")
                
            if current >= total:
                self.on_ai_finished()
                    
        except Exception as e:
            print(f"‚ö†Ô∏è Progress Bar Error: {e}")

    def update_ai_progress_legacy(self, current, total, msg):
        self.update_ai_progress(current, total)
        self.lbl_insight.setText(f"LEGACY SCAN: {msg}")

    def on_ai_finished(self):
        """Finalizes the UI and tells the Watchdog to stand down."""
        print("üèÅ [SYSTEM] Analysis Cycle Complete.")
        
        # Tell the watchdog to stop looking for trouble
        if hasattr(self, 'watchdog'):
            self.watchdog.stop_monitoring("ai_analysis")
        
        # 1. Update Button State
        if hasattr(self, 'btn_analyze'):
            self.btn_analyze.setText("‚ú® RE-ANALYZE")
            self.btn_analyze.setEnabled(True)
        
        # 2. UI Cleanup
        if hasattr(self, 'progress_bar'):
            self.progress_bar.hide()
            
        if hasattr(self, 'lbl_insight'):
            total = len(self.image_data)
            self.lbl_insight.setText(f"‚úÖ AI Analysis Complete: {total} images.")
            
        self.update_filter_styles()

    # --- ADMIN & UTILITY METHODS ---

    def open_settings(self):
        """
        INDUSTRIAL CONFIGURATION: Merges project maintenance with AI module control.
        Toggles here directly impact CPU/RAM utilization for 20,000+ image scalability.
        """
        from PySide6.QtWidgets import QDialog, QVBoxLayout, QLabel, QPushButton, QMessageBox, QCheckBox, QSlider
        
        dialog = QDialog(self)
        dialog.setWindowTitle("System Settings & AI Config")
        dialog.setFixedWidth(350)
        layout = QVBoxLayout(dialog)
        layout.setSpacing(15)
        
        # --- SECTION 1: HEADER ---
        layout.addWidget(QLabel("<b>DSR PRO V2 ARCHITECTURE CONTROL</b>"))
        layout.addWidget(QLabel("Manage session memory and modular AI layers."))
        
        # --- SECTION 2: AI MODULE TOGGLES (New logic for memory saving) ---
        # Facial AI Toggle
        self.check_face_ai = QCheckBox("Enable Facial Recognition (Memory Intensive)")
        self.check_face_ai.setChecked(getattr(self, 'enable_face_ai', True))
        self.check_face_ai.setToolTip("Turn off to save significant RAM on large galleries.")
        layout.addWidget(self.check_face_ai)
        
        # Burst Detection Toggle
        self.check_burst_ai = QCheckBox("Enable Burst Shot Identification")
        self.check_burst_ai.setChecked(getattr(self, 'enable_burst_ai', True))
        layout.addWidget(self.check_burst_ai)
        
        # --- SECTION 3: PERFORMANCE SLIDERS ---
        layout.addWidget(QLabel("AI Sensitivity Threshold (Score %):"))
        self.slider_threshold = QSlider(Qt.Horizontal)
        self.slider_threshold.setRange(10, 95)
        self.slider_threshold.setValue(int(getattr(self, 'ai_threshold', 45)))
        layout.addWidget(self.slider_threshold)
        
        # --- SECTION 4: THE RESET BUTTON (Original Logic Strictly Preserved) ---
        line = QFrame(); line.setFrameShape(QFrame.HLine); line.setFrameShadow(QFrame.Sunken)
        layout.addWidget(line)
        
        btn_reset = QPushButton("üß® Nuclear Reset Session")
        btn_reset.setStyleSheet("""
            QPushButton { 
                background: #331111; color: #FF9999; border: 1px solid #552222; 
                padding: 10px; font-weight: bold; border-radius: 5px; 
            }
            QPushButton:hover { background: #441111; }
        """)
        
        def handle_reset():
            confirm = QMessageBox.question(
                dialog, "Confirm Wipe", 
                "Are you sure? This will delete all AI scores and manual choices for this folder.",
                QMessageBox.Yes | QMessageBox.No
            )
            if confirm == QMessageBox.Yes:
                self.nuclear_reset() # Calls your existing logic
                dialog.accept()

        btn_reset.clicked.connect(handle_reset)
        layout.addWidget(btn_reset)

        # --- SECTION 5: APPLY & SAVE ---
        btn_apply = QPushButton("Apply System Optimization")
        btn_apply.setStyleSheet("background: #D4B37D; color: #000; font-weight: bold; padding: 12px; border-radius: 6px;")
        
        def apply_changes():
            # Sync local attributes to UI state
            self.enable_face_ai = self.check_face_ai.isChecked()
            self.enable_burst_ai = self.check_burst_ai.isChecked()
            self.ai_threshold = self.slider_threshold.value()
            
            # Dynamic UI Clean-up based on memory-saving choices
            if not self.enable_face_ai and hasattr(self, 'person_container'):
                self.person_container.hide()
            elif self.enable_face_ai and hasattr(self, 'person_container'):
                self.person_container.show()
                
            print(f"‚öôÔ∏è [SYSTEM] Applied Config: FaceAI={self.enable_face_ai}, Threshold={self.ai_threshold}")
            dialog.accept()

        btn_apply.clicked.connect(apply_changes)
        layout.addWidget(btn_apply)
        
        layout.addStretch()
        dialog.exec()
        
        def handle_reset():
            confirm = QMessageBox.question(
                dialog, "Confirm Wipe", 
                "Are you sure? This will delete all AI scores and manual choices for this folder.",
                QMessageBox.Yes | QMessageBox.No
            )
            if confirm == QMessageBox.Yes:
                self.nuclear_reset() # Calls the logic we built previously
                dialog.accept()

        btn_reset.clicked.connect(handle_reset)
        layout.addWidget(btn_reset)
        layout.addStretch()
        dialog.exec()
    
    def nuclear_reset(self):
        """The actual logic that wipes data and refreshes UI."""
        print("üß® [RESET] Gallery is wiping data...")
        try:
            # 1. Database Purge
            if hasattr(self, 'db') and self.db:
                self.db.clear_folder_data(self.current_folder)
            
            # 2. Local Variable Reset
            for img in self.image_data:
                img['status'] = 'pending'
                img['score'] = 0
                img['is_manual'] = False
                
            # 3. Refresh the View
            self.rebuild_grid() 
            self.update_filter_styles()
            
            if hasattr(self, 'lbl_insight'):
                self.lbl_insight.setText("‚ôªÔ∏è SYSTEM RESET COMPLETE")
            print("‚úÖ [RESET] Success.")

        except Exception as e:
            print(f"‚ùå [RESET] Failed: {e}")
    
    def run_export(self):
        """Finalizes the project by moving Keep images to a destination folder."""
        # 1. Gather all 'Keep' images
        keep_list = [img for img in self.image_data if img['status'] == 'keep']
        
        if not keep_list:
            self.lbl_insight.setText("‚ö†Ô∏è EXPORT FAILED: NO 'KEEP' IMAGES FOUND.")
            return

        # 2. Define Export Path
        export_path = os.path.join(self.current_folder, "DSR_PRO_SELECTED")
        if not os.path.exists(export_path):
            os.makedirs(export_path)

        # 3. Copy files (The actual delivery)
        exported_count = 0
        for img in keep_list:
            try:
                src = img['path']
                dst = os.path.join(export_path, os.path.basename(src))
                shutil.copy2(src, dst) # copy2 preserves metadata
                exported_count += 1
            except Exception as e:
                print(f"‚ùå Export Error on {src}: {e}")

        # 4. Final Success Feedback
        self.lbl_insight.setText(f"üéâ SUCCESS: {exported_count} IMAGES EXPORTED TO {export_path}")
        print(f"üíé Project Complete: {exported_count} files delivered.")

    # --- CORE VIEW LOGIC ---

    def cycle_grid_size(self):
        self.GRID_COLS += 1
        if self.GRID_COLS > 6: self.GRID_COLS = 3
        self.btn_settings.setText(f"‚öôÔ∏è {self.GRID_COLS}x{self.GRID_COLS}")
        self.rebuild_grid()

    def set_filter(self, mode):
        self.filter_state = mode
        self.update_filter_styles()
        self.rebuild_grid()
        if self.current_index not in self.visible_indices and self.visible_indices:
            self.current_index = self.visible_indices[0]
            self.multi_selection = {self.current_index}
        if self.view_stack.currentIndex() == 1: self.refresh_zen()
        self.setFocus()

    def update_filter_styles(self):
        """Unified method to update filter button styles and counts."""
        def get_style(active, color="#D4B37D"):
            return f"QPushButton {{ color: {'#666' if not active else color}; background-color: {'#1A1A1A' if active else 'transparent'}; border: 1px solid {color if active else '#333'}; border-radius: 4px; font-weight: bold; font-size: 11px; }} QPushButton:hover {{ background-color: #111; color: {color}; }}"
        
        self.btn_all.setStyleSheet(get_style(self.filter_state == "all", "#D4B37D"))
        self.btn_keep.setStyleSheet(get_style(self.filter_state == "keep", "#98C379"))
        self.btn_pending.setStyleSheet(get_style(self.filter_state == "pending", "#E5C07B"))
        self.btn_reject.setStyleSheet(get_style(self.filter_state == "reject", "#E06C75"))
        self.btn_ai_best.setStyleSheet(get_style(self.filter_state == "ai_best", "#88E0EF"))
        
        total = len(self.image_data)
        keep = sum(1 for d in self.image_data if d['status'] == 'keep')
        reject = sum(1 for d in self.image_data if d['status'] == 'reject')
        pending = sum(1 for d in self.image_data if d['status'] == 'pending')
        ai_best = sum(1 for d in self.image_data if d.get('score', 0) >= 45)

        self.btn_all.setText(f"ALL ({total})")
        self.btn_keep.setText(f"KEEP ({keep})")
        self.btn_pending.setText(f"PENDING ({pending})")
        self.btn_reject.setText(f"REJECT ({reject})")
        self.btn_ai_best.setText(f"‚ú® AI BEST ({ai_best})")
        
        self.update_album_stats(keep)

    def update_album_stats(self, keep_count=None):
        if not hasattr(self, 'lbl_album'): return
        if TITANIUM_AVAILABLE and hasattr(self, 'album_tracker'):
            stats = self.album_tracker.calculate_progress(self.image_data)
            current = stats['current']; target = stats['target']; is_over = stats['is_over']
        else:
            if keep_count is None: keep_count = sum(1 for d in self.image_data if d['status'] == 'keep')
            current = keep_count; target = self.album_target; is_over = current > target

        self.lbl_album.setText(f"ALBUM: {current}/{target}")
        if is_over: self.lbl_album.setStyleSheet("color:#E06C75; font-size:10px; font-weight:bold; padding-right:20px;")
        else: self.lbl_album.setStyleSheet("color:#D4B37D; font-size:10px; font-weight:bold; padding-right:20px;")

    def apply_settings(self, settings):
        self.GRID_COLS = settings.get('grid_cols', 4)
        self.auto_advance = settings.get('auto_advance', True)
        self.album_target = settings.get('album_target', 100)
        if self.image_data: self.rebuild_grid()

    def clear_all(self):
        self.image_data = []
        self.path_registry.clear() # ADDED: O(1) Safety
        self.visible_indices = []
        self.rendered_count = 0
        self.current_index = 0
        self.loaded_thumbnails_count = 0
        while self.grid_layout.count():
            item = self.grid_layout.takeAt(0)
            if item.widget(): item.widget().deleteLater()
        while self.strip_layout.count():
            item = self.strip_layout.takeAt(0)
            if item.widget(): item.widget().deleteLater()

    def load_images(self, folder_path):
        if not folder_path or not os.path.isdir(folder_path): return
        
        # Safe Thread Shutdown
        if self.scanner_worker and self.scanner_worker.isRunning():
            self.scanner_worker.stop()
            self.scanner_worker.wait()
            
        if hasattr(self, 'ai_worker') and self.ai_worker:
             try:
                 self.ai_worker.signals.result.disconnect()
                 self.ai_worker.signals.progress.disconnect()
                 self.ai_worker.signals.finished.disconnect()
             except: pass
             self.ai_worker.stop()
             self.ai_worker = None
        
        # Hard Reset to fix switching
        self.clear_all()
        
        self.btn_analyze.set_loading(False)
        self.progress_bar.hide()
        self.lbl_insight.setText("SYSTEM READY")
        self.guidance_banner.show()
        self.set_filter("all")
        
        self.current_folder = folder_path
        self.lbl_insight.setText(f"Scanning: {folder_path}")
        self.progress_bar.setRange(0, 0); self.progress_bar.show()
        
        QApplication.processEvents()
        
        self.scanner_worker = FolderScanner(folder_path)
        self.scanner_worker.batch_found.connect(self.on_batch_found)
        self.scanner_worker.finished.connect(self.on_scan_finished)
        self.scanner_worker.start()

    def on_batch_found(self, batch_paths):
        """Industrial Ingestion: Now with Face Cluster Support."""
        start_idx = len(self.image_data)
        new_items = []
        
        # We track the timestamp of the last processed image to detect bursts
        last_time = 0
        if self.image_data:
            try: last_time = os.path.getmtime(self.image_data[-1]['path'])
            except: pass

        for p in batch_paths:
            # 1. O(1) Duplicate Check (Existing Logic Preserved)
            if p not in self.path_registry:
                self.path_registry.add(p)
                
                # 2. Burst Detection Logic (Existing Logic Preserved)
                is_burst = False
                try:
                    curr_time = os.path.getmtime(p)
                    if abs(curr_time - last_time) < 0.5: 
                        is_burst = True
                    last_time = curr_time
                except: pass

                # 3. TITANIUM DATA DICTIONARY (Expanded for Facial Clustering)
                new_items.append({
                    'path': p, 
                    'status': 'pending', 
                    'rating': 0, 
                    'score': 0,
                    'tags': "#NEW #BURST" if is_burst else "#NEW",
                    'color': None, 
                    'vip_level': 'None', 
                    'confidence': 'high', 
                    'is_manual': False, 
                    'ai_pick': False,
                    'burst_group': is_burst,
                    # NEW FACIAL HOOKS:
                    'face_ids': [],     # List of Person IDs (e.g. ['Person_1', 'Person_3'])
                    'primary_face': None, # The Vector ID of the largest face found
                    'biological_metrics': {'eyes_open': True, 'face_detected': False}
                })
        
        # 4. Database Sync (Existing Logic Preserved)
        if self.db:
            saved = self.db.fetch_folder_data(self.current_folder)
            for img in new_items:
                if img['path'] in saved: 
                    img.update(saved[img['path']])
        
        self.image_data.extend(new_items)
        
        # 5. Index Management
        for i in range(len(new_items)):
            self.visible_indices.append(start_idx + i)
        
        # 6. TRIGGER UI UPDATES
        self.refresh_sidebar_tags() 
        # ADDED: This will be used once the Face section is built in the sidebar
        if hasattr(self, 'refresh_person_clusters'): self.refresh_person_clusters()
        
        self.update_filter_styles()
        self.render_next_batch()
        
        self.lbl_insight.setText(f"üì• IMPORTED: {len(self.image_data)} IMAGES | READY FOR FACIAL SCAN")
     
    def refresh_sidebar_tags(self):
        """Logic #5: Dynamic Tag Extraction. Scans image_data for all unique #hashtags."""
        if not hasattr(self, 'sidebar_layout'): return
        
        # 1. Extract all unique tags
        unique_tags = set()
        for img in self.image_data:
            tags = img.get('tags', "").split()
            for t in tags:
                if t.startswith("#"): unique_tags.add(t)
        
        # 2. Clear old tag buttons (leaving standard filters untouched)
        # We assume your sidebar layout has a specific 'tag_section' widget
        if hasattr(self, 'tag_container'):
            while self.tag_layout.count():
                item = self.tag_layout.takeAt(0)
                if item.widget(): item.widget().deleteLater()
        else:
            self.tag_container = QWidget()
            self.tag_layout = QVBoxLayout(self.tag_container)
            self.sidebar_layout.addWidget(QLabel("QUICK TAGS"))
            self.sidebar_layout.addWidget(self.tag_container)

        # 3. Create Luxury Tag Chips
        for tag in sorted(list(unique_tags)):
            btn = QPushButton(tag)
            btn.setStyleSheet("""
                QPushButton { text-align: left; color: #AAA; background: transparent; border: none; font-size: 10px; }
                QPushButton:hover { color: #D4B37D; }
            """)
            btn.clicked.connect(lambda t=tag: self.apply_tag_filter(t))
            self.tag_layout.addWidget(btn)

    def apply_tag_filter(self, tag_name):
        """Logic #6: One-click filtering for specific AI attributes."""
        print(f"üîç Filtering by Tag: {tag_name}")
        self.lbl_active_tag.setText(f"ACTIVE: {tag_name}")
        self.set_filter(tag_name) # Handled by the updated rebuild_grid we just made
     
    def on_scan_finished(self):
        self.lbl_insight.setText(f"LOAD COMPLETE. {len(self.image_data)} IMAGES.")
        self.progress_bar.hide()
        self.update_filter_styles()
        self.setFocus()

    def rebuild_grid(self):
        """O(n) Performance Engine: Filters images based on Status, Tags, and Face IDs."""
        self.page_grid.setUpdatesEnabled(False)
        
        # Surgical UI Wipe
        while self.grid_layout.count():
            item = self.grid_layout.takeAt(0)
            if item.widget(): item.widget().deleteLater()
            
        for c in range(self.GRID_COLS): 
            self.grid_layout.setColumnStretch(c, 1)
        
        self.visible_indices = []
        
        # THE MATCHING ENGINE
        for i, d in enumerate(self.image_data):
            match = False
            
            # 1. Bucket Logic (Existing Logic Preserved)
            if self.filter_state == "all": 
                match = True
            elif self.filter_state == "keep" and d['status'] == "keep": 
                match = True
            elif self.filter_state == "pending" and d['status'] == "pending": 
                match = True
            elif self.filter_state == "reject" and d['status'] == "reject": 
                match = True
            elif self.filter_state == "ai_best" and d.get('score', 0) >= 45: 
                match = True
                
            # 2. METADATA TAG LOGIC (Existing Logic Preserved)
            if self.filter_state.startswith("#"):
                match = self.filter_state.lower() in d.get('tags', "").lower()

            # 3. FACIAL RECOGNITION LOGIC (NEW)
            # If state is 'face_Person_1', we look into the face_ids list
            if self.filter_state.startswith("face_"):
                target_person_id = self.filter_state.replace("face_", "")
                if target_person_id in d.get('face_ids', []):
                    match = True

            if match:
                self.visible_indices.append(i)
        
        # Progressive Re-rendering
        self.rendered_count = 0
        self.render_next_batch()
        
        self.page_grid.setUpdatesEnabled(True)
        self.setFocus()
    def render_next_batch(self):
        if self.is_rendering_batch: return
        self.is_rendering_batch = True
        
        # FIX: Dynamic Grid Size Calculation
        available_w = self.scroll.width() - 40
        if available_w < 100: available_w = 800
        card_size = int(available_w / self.GRID_COLS) - 15
        if card_size < 100: card_size = 100
        
        limit = min(self.rendered_count + self.BATCH_SIZE, len(self.visible_indices))
        for i in range(self.rendered_count, limit):
            idx = self.visible_indices[i]
            d = self.image_data[idx]
            # Pass calculated width
            card = GridCard(idx, d, (idx == self.current_index), (idx in self.multi_selection), width=card_size)
            card.clicked.connect(self.on_card_click)
            card.double_clicked.connect(lambda: self.set_mode(1)) 
            card.image_loaded.connect(self.update_load_status)
            self.grid_layout.addWidget(card, i // self.GRID_COLS, i % self.GRID_COLS)
        self.rendered_count = limit
        
        self.is_rendering_batch = False

    def update_load_status(self):
        self.loaded_thumbnails_count += 1
        if self.loaded_thumbnails_count % 10 == 0:
            total = len(self.image_data)
            self.lbl_insight.setText(f"GENERATING PREVIEWS: {self.loaded_thumbnails_count} / {total}")

    def check_scroll_position(self, value):
        if value > (self.scroll.verticalScrollBar().maximum() * 0.9):
            if self.rendered_count < len(self.visible_indices): self.render_next_batch()

    def scroll_to_current(self):
        if self.current_index >= self.rendered_count:
            self.rendered_count = self.current_index + 20; self.render_next_batch()
        if self.current_index in self.visible_indices:
            idx = self.visible_indices.index(self.current_index)
            if idx < self.grid_layout.count():
                w = self.grid_layout.itemAt(idx).widget()
                if w: self.scroll.ensureWidgetVisible(w)

    def on_card_click(self, idx, mods=Qt.NoModifier):
        prev_idx = self.current_index; self.current_index = idx
        if mods & Qt.ShiftModifier: pass 
        elif not (mods & Qt.ControlModifier): self.multi_selection = {idx}
        
        for i in range(self.grid_layout.count()):
            w = self.grid_layout.itemAt(i).widget()
            if w and w.index == idx: w.update_style(True, False)
            elif w and w.index == prev_idx: w.update_style(False, False)
            
        if self.current_folder and self.db: self.db.save_session_state(self.current_folder, self.current_index)
        QTimer.singleShot(10, self.update_insights)
        if self.view_stack.currentIndex() == 1: self.refresh_zen()
        self.setFocus()

    def update_card_style(self, idx_global):
        """Updates borders AND debug badges."""
        if idx_global in self.visible_indices:
            layout_idx = self.visible_indices.index(idx_global)
            item = self.grid_layout.itemAt(layout_idx)
            if item and item.widget():
                card = item.widget()
                # 1. Update the Border
                card.update_style((idx_global == self.current_index), (idx_global in self.multi_selection))
                # 2. Refresh the Overlays (This shows the % and Status)
                if hasattr(card, 'setup_overlays'):
                    card.setup_overlays()

    def apply_decision(self, status=None, rating=None, color=None):
        """Master logic for moving images between buckets & updating Tag Intelligence."""
        if not self.image_data: return
        
        # Target the currently selected image
        idx = self.current_index
        target = self.image_data[idx]

        # 1. Update data package (Existing Logic Preserved)
        if status: target['status'] = status
        if rating is not None: target['rating'] = rating
        if color: target['color'] = color
        
        target['is_manual'] = True # Mark as human-verified

        # 2. ADVANCED LOGIC: Selection Tagging
        # Ensures manual picks are searchable via sidebar #tags
        if status == 'keep' and "#SELECTED" not in target.get('tags', ""):
            current_tags = target.get('tags', "")
            target['tags'] = f"{current_tags} #SELECTED".strip()

        # 3. Memory Sync: Save to Database (Existing Logic Preserved)
        if self.db:
            self.db.save_decision(
                target['path'], 
                target['status'], 
                target.get('rating', 0), 
                target.get('color')
            )

        # 4. Visual Sync
        self.update_card_style(idx)
        self.update_filter_styles()
        self.refresh_sidebar_tags() # ADDED: Keeps your Sidebar Tags updated in real-time

        # 5. Efficiency: Auto-advance (Existing Logic Preserved)
        if self.auto_advance:
            self.move_index(1)
        
        self.setFocus()
    def move_index(self, delta):
        try:
            curr_vis_idx = self.visible_indices.index(self.current_index)
            new_vis_idx = curr_vis_idx + delta
            if 0 <= new_vis_idx < len(self.visible_indices):
                new_global = self.visible_indices[new_vis_idx]
                if new_vis_idx >= self.rendered_count: self.render_next_batch()
                self.on_card_click(new_global)
                if new_vis_idx * self.GRID_COLS < self.grid_layout.count():
                      w = self.grid_layout.itemAt(new_vis_idx).widget()
                      if w: self.scroll.ensureWidgetVisible(w)
        except: pass

    def perform_undo(self): 
        if TITANIUM_AVAILABLE and hasattr(self, 'safety_net'):
            last_states = self.safety_net.pop_undo()
            if last_states:
                for img_state in last_states:
                    for i, img in enumerate(self.image_data):
                        if img['path'] == img_state['path']:
                            self.image_data[i] = img_state
                            self.update_card_style(i)
                            break
                self.update_filter_styles()
                self.update_album_stats()
            return

        if not self.undo_stack: return
        idxs, prevs = self.undo_stack.pop()
        curr_states = [copy.deepcopy(self.image_data[i]) for i in idxs]
        self.redo_stack.append((idxs, curr_states))
        for i, idx in enumerate(idxs): 
            self.image_data[idx] = prevs[i]
            if self.db: self.db.save_decision(self.image_data[idx]['path'], self.image_data[idx]['status'], self.image_data[idx]['rating'], self.image_data[idx]['color'])
            self.update_card_style(idx)
        self.update_filter_styles()

    def perform_redo(self):
        if not self.redo_stack: return
        idxs, nexts = self.redo_stack.pop()
        curr_states = [copy.deepcopy(self.image_data[i]) for i in idxs]
        self.undo_stack.append((idxs, curr_states))
        for i, idx in enumerate(idxs):
            self.image_data[idx] = nexts[i]
            if self.db: self.db.save_decision(self.image_data[idx]['path'], self.image_data[idx]['status'], self.image_data[idx]['rating'], self.image_data[idx]['color'])
            self.update_card_style(idx)
        self.update_filter_styles()

    def launch_export(self):
        dlg = ExportDialog(self.image_data, self)
        dlg.exec_()

    def set_mode(self, index):
        # FIX: Prevent crash if Zen mode clicked with no images
        if index == 1 and not self.image_data:
            self.lbl_insight.setText("‚ö†Ô∏è Load Images First!")
            return
            
        self.view_stack.setCurrentIndex(index)
        if index == 1: self.refresh_zen()
        self.setFocus()
    
    def refresh_zen(self):
        if not self.image_data: return
        if 0 <= self.current_index < len(self.image_data):
            data = self.image_data[self.current_index]
            self.zen_viewer.set_image(data['path'])
            self.lbl_zen_header.setText(f"{os.path.basename(data['path'])}  |  ({self.current_index + 1} / {len(self.image_data)})")

    def update_insights(self):
        pass
        
    def toggle_lights_out(self):
        self.lights_out = not self.lights_out
        if self.lights_out:
            self.sidebar_panel.hide()
            self.queue_bar.hide()
            self.filter_bar.hide()
        else:
            self.sidebar_panel.show()
            self.top_bar.show()
            self.queue_bar.show()
            self.filter_bar.show()
        self.setFocus()

    def closeEvent(self, event):
        """SURGICAL SHUTDOWN: Ensures no thread is left behind."""
        print("üõë [SYSTEM] Initiating Shutdown Protocol...")
        if self.scanner_worker: self.scanner_worker.stop()
        if self.ai_worker: self.ai_worker.stop()
        QThreadPool.globalInstance().clear()
        event.accept()

    def keyPressEvent(self, e):
        """The Unified Master Control Hub for the Selection Nerve System."""
        k = e.key()
        mods = e.modifiers()
        
        # --- MODE TOGGLING ---
        if k == Qt.Key_Escape:
            self.set_mode(0) # Exit Zen Mode
            if self.lights_out: # Exit Focus Mode
                self.toggle_lights_out()
            return

        # --- NAVIGATION ---
        elif k == Qt.Key_Right: self.move_index(1)
        elif k == Qt.Key_Left: self.move_index(-1)
        elif k == Qt.Key_Up: self.move_index(-self.GRID_COLS)
        elif k == Qt.Key_Down: self.move_index(self.GRID_COLS)
        elif k == Qt.Key_G: self.set_mode(0)
        elif k == Qt.Key_E: self.set_mode(1)
        elif k == Qt.Key_L: self.toggle_lights_out()

        # --- SELECTION & DECISIONS ---
        elif k == Qt.Key_C or k == Qt.Key_Space:
            self.apply_decision(status='keep')     # GREEN
        elif k == Qt.Key_X or k == Qt.Key_Backspace or k == Qt.Key_Delete:
            self.apply_decision(status='reject')   # RED
        elif k == Qt.Key_V:
            self.apply_decision(status='pending')  # GOLD

        # --- UNDO / REDO ---
        elif (k == Qt.Key_Z and mods & Qt.ControlModifier) or k == Qt.Key_U: self.perform_undo()
        elif k == Qt.Key_R: self.perform_redo()
        
        # --- RATINGS & COLORS ---
        elif k in [Qt.Key_1, Qt.Key_2, Qt.Key_3, Qt.Key_4, Qt.Key_5]: 
            if e.text().isdigit(): self.apply_decision(rating=int(e.text()))
        elif k in [Qt.Key_6, Qt.Key_7, Qt.Key_8, Qt.Key_9]: 
            color_map = {Qt.Key_6:'red', Qt.Key_7:'yellow', Qt.Key_8:'green', Qt.Key_9:'blue'}
            if k in color_map: self.apply_decision(color=color_map[k])
    
    def refresh_sidebar_tags(self):
        """
        DYNAMIC TAG EXTRACTION: Scans all 1,300+ images for unique #hashtags 
        and builds the clickable sidebar list in real-time.
        """
        if not hasattr(self, 'sidebar_layout'): return
        
        # 1. Extract and Sort unique tags from the entire dataset
        unique_tags = set()
        for img in self.image_data:
            # Splits string like "#NEW #BURST" into individual tags
            tags_list = img.get('tags', "").split()
            for t in tags_list:
                if t.startswith("#"): 
                    unique_tags.add(t.upper()) # Normalize to uppercase
        
        # 2. UI MAINTENANCE: Create or Clear the Tag Container
        # This prevents the sidebar from growing infinitely every time you click a button.
        if not hasattr(self, 'tag_container'):
            # First time setup
            self.tag_container = QWidget()
            self.tag_layout = QVBoxLayout(self.tag_container)
            self.tag_layout.setContentsMargins(0, 10, 0, 0)
            self.tag_layout.setSpacing(2)
            
            # Label for the section
            lbl_title = QLabel("AI SMART TAGS")
            lbl_title.setStyleSheet("color: #555; font-size: 9px; font-weight: bold; margin-top: 15px;")
            self.sidebar_layout.addWidget(lbl_title)
            self.sidebar_layout.addWidget(self.tag_container)
        else:
            # Surgical Clear of old tag buttons
            while self.tag_layout.count():
                item = self.tag_layout.takeAt(0)
                if item.widget(): item.widget().deleteLater()

        # 3. GENERATE LUXURY TAG BUTTONS
        for tag in sorted(list(unique_tags)):
            # Create a professional mini-button for each hashtag
            btn = QPushButton(tag)
            btn.setFocusPolicy(Qt.NoFocus)
            btn.setCursor(Qt.PointingHandCursor)
            
            # High-contrast professional styling
            btn.setStyleSheet("""
                QPushButton { 
                    text-align: left; padding: 5px 10px; color: #888; 
                    background: transparent; border: none; font-size: 10px; 
                    font-family: 'Segoe UI', sans-serif;
                }
                QPushButton:hover { color: #D4B37D; background: #111; border-radius: 4px; }
            """)
            
            # Connection to the Filter Engine we updated previously
            btn.clicked.connect(lambda checked=False, t=tag: self.apply_tag_filter(t))
            self.tag_layout.addWidget(btn)

        # 4. Finish sidebar with a stretch to keep everything at the top
        self.tag_layout.addStretch()

    def apply_tag_filter(self, tag_name):
        """
        TAG ACTION: One-click filtering for AI-detected sequences or attributes.
        """
        print(f"üîç [FILTER] Applying Metadata Filter: {tag_name}")
        
        # Update the active label we added in setup_filter_bar
        if hasattr(self, 'lbl_active_tag'):
            self.lbl_active_tag.setText(f"FILTER: {tag_name}")
            
        # Trigger the master filter engine
        self.set_filter(tag_name.lower())
        
    def refresh_person_clusters(self):
        """
        FACIAL INTELLIGENCE: Groups images by Face IDs 
        and creates a 'People' section in the sidebar.
        """
        # MEMORY GUARD: If user turned this off in settings, stop immediately.
        if not getattr(self, 'enable_face_ai', True): return
        if not hasattr(self, 'sidebar_layout'): return
        
        # 1. Calculate Person Clusters
        person_counts = {}
        for img in self.image_data:
            for f_id in img.get('face_ids', []):
                person_counts[f_id] = person_counts.get(f_id, 0) + 1
        
        if not person_counts: return # Don't show empty header

        # 2. UI MAINTENANCE: Create or Clear Container
        if not hasattr(self, 'person_container'):
            self.person_container = QWidget()
            self.person_layout = QVBoxLayout(self.person_container)
            self.person_layout.setContentsMargins(0, 5, 0, 0)
            self.person_layout.setSpacing(2)
            
            lbl = QLabel("PEOPLE / SUBJECTS")
            lbl.setStyleSheet("color: #555; font-size: 9px; font-weight: bold; margin-top: 15px;")
            self.sidebar_layout.addWidget(lbl)
            self.sidebar_layout.addWidget(self.person_container)
        else:
            while self.person_layout.count():
                item = self.person_layout.takeAt(0)
                if item.widget(): item.widget().deleteLater()

        # 3. GENERATE PERSON CHIPS
        for p_id, count in sorted(person_counts.items()):
            btn = QPushButton(f"üë§ {p_id.replace('_', ' ')} ({count})")
            btn.setFocusPolicy(Qt.NoFocus)
            btn.setCursor(Qt.PointingHandCursor)
            btn.setStyleSheet("""
                QPushButton { text-align: left; padding: 5px 10px; color: #888; border: none; font-size: 10px; }
                QPushButton:hover { color: #D4B37D; background: #111; }
            """)
            btn.clicked.connect(lambda checked=False, p=p_id: self.filter_by_person(p))
            self.person_layout.addWidget(btn)

        # 3. Create Person Filter Buttons
        for p_id, count in person_counts.items():
            btn = QPushButton(f"üë§ {p_id} ({count})")
            btn.setStyleSheet("text-align: left; color: #AAA; background: transparent; border: none; font-size: 10px;")
            btn.clicked.connect(lambda p=p_id: self.filter_by_person(p))
            self.person_layout.addWidget(btn)

    def filter_by_person(self, p_id):
        """Filters the entire grid to show only images containing a specific person."""
        print(f"üéØ [FOCUS] Filtering for Subject ID: {p_id}")
        self.filter_state = f"face_{p_id}"
        
        if hasattr(self, 'lbl_active_tag'):
            self.lbl_active_tag.setText(f"SUBJECT: {p_id}")
            
        self.rebuild_grid()